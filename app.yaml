# Здраствуйте, HR и SRE команды Mindbox!
# Меня зовут Дьяченко Юрий, и это тестовое задание на на вакансию SRE\DevOps-инженер (стажёр)

apiVersion: apps/v1
kind: Deployment
metadata:
  name: app
  labels:
    app: app
spec:
  # Начнём с количества реплик. 
  # Да, нагрузочное тестирование показало, то 4 пода справляются с пиковой нагрузкой, 
  # но 5 мне кажется более правильным решением по следующим причинам:
  # - это тестирование, то есть реальная нагрузка может быть и больше, в таком случае лучше иметь запас;
  # - так как у нас пять нод, в целях обеспечения отказоустойчивости круто было бы разнести по поду на каждую ноду, 
  # ведь если упадёт одна нода при 5 репликах, это не повлияет на общую работоспособность приложения, 
  # а если у нас пик и реплик изначально было 4 и отказывает одна нода?
  replicas: 5
  selector:
    matchLabels:
      app: app
  template:
    metadata:
      labels:
        app: app
    spec:
      affinity:
        # Помните про идею разнести по под на ноду? Вот реализация :)
        # Я думаю всё таки это правило должно быть рекомендательным, 
        # нежели обязательным, потому что не хочется чтобы какие-то поды висели в Pending.
        # Это я, так сказать, балансирую решение, принятое выше, на случай, 
        # если одна или даже две ноды будут недоступны, поды всё равно будут размещены на доступных. 
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 100
              podAffinityTerm:
                labelSelector:
                  matchExpressions:
                    - key: app
                      operator: In
                      values:
                        - app
                topologyKey: "kubernetes.io/hostname"
      containers:
        - name: app
          image: app:latest
          # Далее про ресурсы. 
          resources:
            # Так как в основном потребление ресурсов ровное и держится на 0.1 CPU и 128M, то такие реквесты и поставим.
            requests:
              cpu: 100m
              memory: 128Mi
            # Лимиты обеспечат нам свободу по ресурсам в первых запросах и на пиковых нагрузках.
            limits:
              cpu: 1
              # Так как наказание за превышение лимита по memory не тротлинг, а OOM - поставим двойной запас.
              memory: 256Mi
          # Проверка на то, готов ли реально под к работе пригодится.
          # Зная, что приложению для старта требуется 5-10 секунд ставим первую пробу на 10, а остальные с интервалом в 5.
          readinessProbe:
            httpGet:
              path: /healthz
              port: 80
            initialDelaySeconds: 10
            periodSeconds: 5
          ports:
            - containerPort: 80

---
apiVersion: v1
kind: Service
metadata:
  name: app-service
  labels:
    app: app
spec:
  type: LoadBalancer
  selector:
    app: app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
